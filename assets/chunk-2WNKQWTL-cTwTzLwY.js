const{Channel:O}=__STORYBOOK_MODULE_CHANNELS__,{global:a}=__STORYBOOK_MODULE_GLOBAL__,{logger:s}=__STORYBOOK_MODULE_CLIENT_LOGGER__,{STORY_RENDERED:N,UPDATE_STORY_ARGS:g,RESET_STORY_ARGS:E,UPDATE_GLOBALS:D,FORCE_RE_RENDER:S}=__STORYBOOK_MODULE_CORE_EVENTS__;function C(){let e={setHandler:()=>{},send:()=>{}};return new O({transport:e})}var k=class{constructor(){this.getChannel=()=>{if(!this.channel){let e=C();return this.setChannel(e),e}return this.channel},this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel},this.ready=()=>this.promise,this.hasChannel=()=>!!this.channel,this.hasServerChannel=()=>!!this.serverChannel,this.setChannel=e=>{this.channel=e,this.resolve()},this.setServerChannel=e=>{this.serverChannel=e},this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},h="__STORYBOOK_ADDONS_PREVIEW";function v(){return a[h]||(a[h]=new k),a[h]}var c=v(),w=(e,t)=>e.length===t.length&&e.every((r,o)=>r===t[o]),l=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function d(){return a.STORYBOOK_HOOKS_CONTEXT||null}function _(){let e=d();if(e==null)throw l();return e}function R(e,t,r){let o=_();if(o.currentPhase==="MOUNT"){r!=null&&!Array.isArray(r)&&s.warn(`${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`);let n={name:e,deps:r};return o.currentHooks.push(n),t(n),n}if(o.currentPhase==="UPDATE"){let n=o.getNextHook();if(n==null)throw new Error("Rendered more hooks than during the previous render.");return n.name!==e&&s.warn(`Storybook has detected a change in the order of Hooks${o.currentDecoratorName?` called by ${o.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),r!=null&&n.deps==null&&s.warn(`${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),r!=null&&n.deps!=null&&r.length!==n.deps.length&&s.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${n.deps}
Incoming: ${r}`),(r==null||n.deps==null||!w(r,n.deps))&&(t(n),n.deps=r),n}throw l()}function f(e,t,r){let{memoizedState:o}=R(e,n=>{n.memoizedState=t()},r);return o}function u(e,t){return f("useCallback",()=>e,t)}function T(e,t){return f(e,()=>({current:t}),[])}function m(){let e=d();if(e!=null&&e.currentPhase!=="NONE")e.hasUpdates=!0;else try{c.getChannel().emit(S)}catch{s.warn("State updates of Storybook preview hooks work only in browser")}}function y(e,t){let r=T(e,typeof t=="function"?t():t),o=n=>{r.current=typeof n=="function"?n(r.current):n,m()};return[r.current,o]}function L(e){return y("useState",e)}function A(){let{currentContext:e}=_();if(e==null)throw l();return e}function b(){let e=c.getChannel(),{id:t,args:r}=A(),o=u(i=>e.emit(g,{storyId:t,updatedArgs:i}),[e,t]),n=u(i=>e.emit(E,{storyId:t,argNames:i}),[e,t]);return[r,o,n]}export{L as a,b as u};
